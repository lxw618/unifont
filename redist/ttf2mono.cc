// ttf2mono font converter, dirty hack :)
// r-lyeh, public domain

#include <stdint.h>
#include <stdio.h>

#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <map>

#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1<<25];
stbtt_fontinfo font;

int main(int argc, char **argv)
{
    if( argc < 2 ) {
        std::cout << "usage: " << argv[0] << " font.ttf" << std::endl;
        return -1;
    }

    std::string filename = argv[1];
    std::string title = filename;
    title = title.substr( title.find_last_of('/') + 1 );
    title = title.substr( title.find_last_of('\\') + 1 );
    title = title.substr( 0, title.find_last_of('.') );

    FILE *fp = fopen(filename.c_str(), "rb");
    fread(ttf_buffer, 1, 1<<25, fp);
    fclose(fp);

    stbtt_InitFont(&font, (const unsigned char *)ttf_buffer, stbtt_GetFontOffsetForIndex((const unsigned char *)ttf_buffer,0));

    auto mk_monospace = [&]( std::vector<int> &bitfont, std::vector<int> &toc, int c, int MAX ) {
        int w, h, xoff, yoff, s = 8;
        unsigned char *bitmap = 0;

        // this is used to determinate if given 'c' is valid or invalid codepoint/unsupported typeface
        static const unsigned char *invalid = 0;
        static int size = 0;
        if( !invalid ) {
            int invalid_codepoint = 0xC0C1;
            bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, &xoff, &yoff);
            invalid = (unsigned char *)malloc( size = w * h );
            memcpy( (unsigned char *)invalid, bitmap, size );
            for( unsigned it = 0; it < size; ++it ) {
                printf( &"\"\\x%02x%s"[ !!(it % w) ], invalid[it], &"\"},\n\0\"}};\n"[ (1+it) < size ? 4 * !!((1+it) % w) : 5 ] );
            }
        }

        bitmap = stbtt_GetCodepointBitmap(&font, 0,stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, &xoff, &yoff);

        if( w*h == size && !memcmp(invalid, bitmap, size) ) {
            return 0;
        }

        toc.push_back( c );

        std::vector<int> font;
        printf("u+%04x %d %d %d %d\n", c, w, h, xoff, yoff);
        for(int j = 0; j < MAX; ++j) {
            font.push_back( 0 );
            if( j >= MAX + yoff && j < (MAX + yoff) + h ) {
                for( int i=0; i < MAX; ++i ) {
                    char ch = i >= xoff && i < xoff + w ? ".x"[(bitmap[(j-(MAX+yoff))*w+i-xoff]>>5) > 0] : '.';
                    font.back() |= (ch != '.') << (MAX - 1 - i);
                    putchar( ch );
                }
            } else {
                printf("%s", std::string(MAX, '.').c_str() );
            }
            printf(" 0x%02x [%d]\n", font.back(), c*MAX+j );
        }
        for( auto &it : font ) {
            bitfont.push_back( it );
        }
        return 1;
    };

    puts("/* generated by ttf2mono.cc; https://github.com/r-lyeh */");
    puts("/*");

    std::vector<int> monofont, toc;
    for( uint32_t x = 0; x <= 0xffff; ++x ) {
        mk_monospace(monofont, toc, x, 8);
    }

    puts("*/");

    printf("%s", "#ifndef __cplusplus\n");

    printf("const unsigned char %s_ttf[] =\n", title.c_str() );
    for( auto end = monofont.size(), it = end - end; it < end; ++it ) {
        printf( &"\"\\x%02x%s"[ !!(it % 16) ], monofont[it], &"\"\n\0\";\n"[ (1+it) < end ? 2 * !!((1+it) % 16) : 3 ] );
    }

    printf("const int %s_ttf_toc[] = {\n", title.c_str() );
    for( auto end = toc.size(), it = end - end; it < end; ++it ) {
        printf( "%6d%s", toc[it], &",\0,\n\0};\n"[ (1+it) >= end ? 5 : 2 * !((1+it) % 16) ] );
    }

    printf("%s", ""
    "/*dichotomic binary search (container must be sorted && supporting sequential access); r-lyeh, public domain */\n"
    "static inline unsigned toc_find( const int *begin, const int *end, int x ) {\n"
    "    unsigned min = 0, max = unsigned( (end - begin) / sizeof(int));\n"
    "    while( min < max ) {\n"
    "        unsigned mid = min + ( max - min ) / 2;\n"
    "        /**/ if( x == begin[mid] ) return mid;\n"
    "        else if( x < begin[mid] ) max = mid;\n"
    "        else min = mid + 1;\n"
    "    }\n"
    "    return ~0u;\n"
    "};\n");

    printf("%s", "#else /* __cplusplus */\n");

    /*
    printf("const std::map<int,const char *> %s_map_cpp8 = {\n", title.c_str() );
    for( auto end = monofont.size(), it = end - end; it < end; ++it ) {
        if( 0 == (it%8) ) {
            printf("{0x%04x,", toc[it/8] );
        }
        printf( &"\"\\x%02x%s"[ !!(it % 8) ], monofont[it], &"\"},\n\0\"}};\n"[ (1+it) < end ? 4 * !!((1+it) % 8) : 5 ] );
    }
    */

    char buf[256];
    printf("const std::map<int,uint64_t> %s_ttf = {\n", title.c_str() );
    for( auto end = monofont.size(), it = end - end; it < end; ++it ) {
        char *ptr = buf;
        if( 0 == (it%8) ) {
            ptr += sprintf(ptr, "{0x%04x,", toc[it/8] );
        }
        ptr += sprintf(ptr, &"0x%02x"[ 2 * !!(it % 8) ], monofont[it] );
        if( (1+it) >= end ) {
            ptr += sprintf(ptr, "%s", "}};\n" );
        } else {
            if( !((1+it) % 8) ) ptr += sprintf(ptr, "%s", "},");
            if( !((1+it) %24) ) ptr += sprintf(ptr, "%s", "\n");
        }
        printf( "%s", buf );
    }

    printf("%s", "#endif /* __cplusplus */\n");

    return 0;
}
